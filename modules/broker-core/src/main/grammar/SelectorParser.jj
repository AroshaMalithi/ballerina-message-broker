/*
 * Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

options {
  STATIC = false;
  UNICODE_INPUT = false;

  // some performance optimizations
  ERROR_REPORTING = false;

}

PARSER_BEGIN(MessageFilter)

/*
 * Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package io.ballerina.messaging.broker.core.selector.generated;

import java.io.StringReader;
import java.util.ArrayList;
import io.ballerina.messaging.broker.core.selector.BooleanExpression;
import io.ballerina.messaging.broker.core.selector.EqualityExpression;
import io.ballerina.messaging.broker.core.selector.GreaterThanExpression;
import io.ballerina.messaging.broker.core.selector.GreaterThanOrEqualExpression ;
import io.ballerina.messaging.broker.core.selector.NotEqualExpression;
import io.ballerina.messaging.broker.core.selector.LessThanExpression;
import io.ballerina.messaging.broker.core.selector.LessThanOrEqualExpression;
import io.ballerina.messaging.broker.core.selector.Addition;
import io.ballerina.messaging.broker.core.selector.Subtraction;
import io.ballerina.messaging.broker.core.selector.Multiplication;
import io.ballerina.messaging.broker.core.selector.Division;
import io.ballerina.messaging.broker.core.selector.ConstantExpression;
import io.ballerina.messaging.broker.core.selector.NOTOperation;
import io.ballerina.messaging.broker.core.selector.ANDOperation;
import io.ballerina.messaging.broker.core.selector.OROperation;
import io.ballerina.messaging.broker.core.selector.NotNull;
import io.ballerina.messaging.broker.core.selector.IsNull;
import io.ballerina.messaging.broker.core.selector.LikeComparision;
import io.ballerina.messaging.broker.core.selector.NotLikeComparision;
import io.ballerina.messaging.broker.core.selector.BetweenComparision;
import io.ballerina.messaging.broker.core.selector.NotBetweenComparision;
import io.ballerina.messaging.broker.core.selector.INcomparision;
import io.ballerina.messaging.broker.core.selector.NotINcomparision;
import io.ballerina.messaging.broker.core.selector.UnaryNegative;
import io.ballerina.messaging.broker.core.selector.Expression;
import io.ballerina.messaging.broker.core.selector.JmsPropertyExpression;

public class MessageFilter {

    public MessageFilter() {
        this(new StringReader(""));
    }

    public MessageFilter(String selectorString) {
        this(new StringReader(selectorString));
    }

    public BooleanExpression parse() throws Exception {
        return parseSelector();
    }

}

PARSER_END(MessageFilter)
SKIP :
{
  " "|"\t"|"\n"|"\r"
}




TOKEN [IGNORE_CASE] :
{
    <  NOT     : "NOT">
  | <  AND     : "AND">
  | <  OR      : "OR">
  | <  BETWEEN : "BETWEEN">
  | <  LIKE    : "LIKE">
  | <  ESCAPE  : " ESCAPE">
  | <  IN      : "IN">
  | <  IS      : "IS">
  | <  TRUE    : "TRUE" >
  | <  FALSE   : "FALSE" >
  | <  NULL    : "NULL" >
}

TOKEN [IGNORE_CASE] :
{

    < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* (["l","L"])? >
  | < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
  | < OCTAL_LITERAL: "0" (["0"-"7"])* >
   | <STRING_LITERAL: "'" (("''") | ~["'"] )* "'">
    | < FLOATING_POINT_LITERAL:
                 (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?            // matches: 12.1 or 3. or 6.9E10 or 5.E10
                  | "." (["0"-"9"])+ (<EXPONENT>)?                      // matches: .8 or .8E10
                   | (["0"-"9"])+ <EXPONENT>                            // matches: 9E10
          >
        | < #EXPONENT: "E" (["+","-"])? (["0"-"9"])+ >
}

TOKEN :
{
    <IDENTIFIER : ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_","$"])*>
}

TOKEN :
    {
     < EQUAL: "=" >
    | < GRATER_THAN: ">" >
    | < LESS_THAN: "<" >
    | < GRATER_EQAL: ">=" >
    | < LESS_EQUAL: "=<" >
    | < NOTEQUAL: "<>" >
    }

BooleanExpression parseSelector() :
{ BooleanExpression value; }
{
     value= OrExpression() <EOF>
     { return value; }
}

BooleanExpression OrExpression():
{
  BooleanExpression value;
 BooleanExpression value1;

}
{
   value=AndExpression()

   (
       <OR>value1=AndExpression(){ value = new OROperation(value,value1);}
   )*

   {return value;}
}

BooleanExpression AndExpression():
{
 BooleanExpression value;
 BooleanExpression value1;
}
{
   value=NotExpression()
   (
       <AND>value1=NotExpression(){ value = new ANDOperation(value,value1);}
   )*

   {return value;}
}

BooleanExpression NotExpression() :
{
    BooleanExpression value;

 }
   {
   (
     <NOT> value = NotExpression(){ value = new NOTOperation(value);}
     | "(" value = ComparisonExpression() ")"
     | value = ComparisonExpression()

   )
     { return value;}
   }

BooleanExpression ComparisonExpression() :
{
    BooleanExpression value;
    Expression left;
    Expression right;
    ArrayList list;
    Expression t;
    Expression u ;
    String a;
    String b;

}
{

    left = sum()

    (
        <EQUAL> right = unary(){ value = new EqualityExpression(left , right);}
       |<GRATER_THAN> right = unary()  { value= new GreaterThanExpression(left , right); }
       |<GRATER_EQAL> right = unary()  { value= new GreaterThanOrEqualExpression(left , right); }
       |<LESS_THAN> right = unary()  { value= new LessThanExpression(left , right); }
       |<LESS_EQUAL> right = unary()  { value= new LessThanOrEqualExpression(left , right); }
       |<NOTEQUAL> right = unary() { value = new NotEqualExpression(left , right);}
       LOOKAHEAD(2)
                     <IS> <NULL>
                     {
                         value = new IsNull(left);
                     }
                     |
                     <IS> <NOT> <NULL>
                     {
                         value = new NotNull(left);
                     }


       |
                     {
        					b=null;
        				}
        		        <LIKE> a = stringLitteral()
        		        	[ <ESCAPE> b = stringLitteral() ]//[] brackets are choose point if we want we can go inside or we can ignore
        		        {
                            value = new LikeComparision(left, a, b);
        		        }
       |
        	        	LOOKAHEAD(2)
        				{
        					b=null;
        				}
        		        <NOT> <LIKE> a = stringLitteral() [ <ESCAPE> b = stringLitteral() ]
        		        {
                            value = new NotLikeComparision(left, a, b);
        		        }

       |<BETWEEN> t= unary() <AND> u = unary()

                    { value = new BetweenComparision(left,t,u);}



       |
       LOOKAHEAD(2)
       <NOT><BETWEEN> t= unary() <AND> u = unary()
             { value = new NotBetweenComparision(left,t,u);}
       | <IN>
         		        "("
         		            a = stringLitteral()
         		            {
         			            list = new ArrayList();
         			            list.add( a );
         		            }
         			        (
         			        	","
         			            a = stringLitteral()
         			            {
         				            list.add( a );
         			            }

         			        )*
         		        ")"
         		        {
         		           value = new  INcomparision(left, list);
         		        }
       |
        LOOKAHEAD(2)
        <NOT> <IN>
          "("
             a = stringLitteral()
          {
         	list = new ArrayList();
         		list.add( a );
         		  }
         			 (
         			  ","
         			  a = stringLitteral()
         			   {
         				  list.add( a );
         			      }

         			        )*
         		        ")"
         		        {
         		           value =  new NotINcomparision(left, list);
         		        }


    )
    { return value; }
}
Expression sum() :
{
 Expression first;
 Expression second;

}
{
   first = factor()
   (
   (
    "+"second= factor(){ first = new Addition(first , second);}
    | "-"second = factor(){ first = new Subtraction(first , second);}
     )
     )*
     {return first;}

}

Expression factor() :
{
  Expression first;
  Expression second;
}
{
   first = unary()
   (
      (
       "*"second= unary(){ first = new  Multiplication(first , second);}
       | "/"second = unary(){ first = new  Division(first , second);}

       )
   )*
        {return first;}


}

Expression unary() :
{
  Expression first;
}
{
    (

       "+" first = element()
       | "-" first = element(){ first = new UnaryNegative(first);}
       | first = element()
    )

    {return first;}
}


Expression element() :
{
 Expression first;
}
{
   (
     first =identifier()
     | first = value()
     |"(" first = sum() ")"
   )
   {return first;}

}


Expression identifier() :
{
    Token t;
    Expression expr;
}
{
    (
        t = <IDENTIFIER>
        {
            expr = new JmsPropertyExpression(t.image);
        }
    )
    {
        return expr;
    }
}

Expression value() :
{
    Expression expr;
    String s;
}
{
    (

        (
             s = stringLitteral()
               {
                   expr = new ConstantExpression(s);
                 }
                )

        | expr = decimalLiteral()
        | expr = floatingPointLiteral()
        | expr = hexLiteral()
        | expr = octalLiteral()


        )

    {
        return expr;
    }
}


String stringLitteral() :
{
    Token t;
    StringBuffer rc = new StringBuffer();
    boolean first=true;
}
{
    t = <STRING_LITERAL>
    {
    	// Decode the sting value.
    	String image = t.image;
    	for( int i=1; i < image.length()-1; i++ ) {
    		char c = image.charAt(i);
    		if( c == '\'' )
    			i++;
   			rc.append(c);
    	}

	    return rc.toString();
    }
}

Expression decimalLiteral() :
{
    Token t;
    Expression expr;
}
{
    t = <DECIMAL_LITERAL>
    {
        String text = t.image;
        expr = ConstantExpression.createFromNumericDecimal(text);
    }
    {
        return expr;
    }
}

Expression floatingPointLiteral():
{
  Token t;
  Expression expr;
}
{
    t= <FLOATING_POINT_LITERAL>
    {
       String text = t.image;
       expr = ConstantExpression.createFromNumericFloat(text);
    }
    {
     return expr;
    }
}
Expression hexLiteral() :
{
    Token t;
    Expression expr;
}
{
    t = <HEX_LITERAL>
    {
        String text = t.image;
        expr = ConstantExpression.createFromNumericHex(text);
    }
    {
        return expr;
    }
}
Expression octalLiteral() :
{
    Token t;
    Expression expr;
}
{
    t = <OCTAL_LITERAL>
    {
        String text = t.image;
        expr = ConstantExpression.createFromNumericOctal(text);
    }
    {
        return expr;
    }
}